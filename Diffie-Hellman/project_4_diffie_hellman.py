# -*- coding: utf-8 -*-
"""Project 4: Diffie-Hellman.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yIErMImMO5fauILV8H4O06zy9OX9Vyj9
"""

#pip install sympy

import subprocess
from sympy import isprime

# Function to generate a prime number using openssl
def generate_prime():
    openssl_process = subprocess.Popen(['openssl', 'prime', '-generate', '-bits', '500'], stdout=subprocess.PIPE)
    prime_number, _ = openssl_process.communicate()
    return int(prime_number.strip())

# Initialize a counter
attempts = 0

# Loop to find a prime number q and check if 2*q + 1 is also prime
while True:
    q = generate_prime()
    print(f"Attempt #{attempts + 1}: Potential q: {q}")

    # Calculate 2*q + 1
    p = 2 * q + 1

    # Check if both q and 2*q + 1 are prime
    if isprime(q) and isprime(p):
        print(f"Found prime q: {q}")
        print(f"Corresponding prime p: {p}")
        break
    else:
        print("Not a valid pair, retrying...")

    # Increment the counter
    attempts += 1

# result of openssl safe random prime number generator and it is strong
#   5365156345180440740693779686938078343544048482796748863278037860394960366196034697199230901753287512957912844315341399197391185253725860300048800439799
p = 5365156345180440740693779686938078343544048482796748863278037860394960366196034697199230901753287512957912844315341399197391185253725860300048800439799

a = 2592467434919754397428328757007326708818966749473729234232786716329323863687002698043166076143662658621075287464936624179055841159803012649743370087607
b = 1287517725278773503241876322205798263967433460366043048576376313928112629035489594278378127083234094345742119066133700502271631917442192756832031995756

def modular_exponentiation(base, exp, mod):
    res = 1
    while (exp > 0):
        if (exp % 2 == 1):
            res = (res * base) % mod
        exp = exp >> 1
        base = (base * base) % mod
    return res


def diffie_hellman(a, p):
    g = 5
    key_a = modular_exponentiation(g, a, p)
    print("key_a: ", key_a)

    key_b = modular_exponentiation(g, b, p)
    print("key_b: ", key_b)




    a_b = a * b


    key_ab = modular_exponentiation(g,a_b,p)
    print("g^(a*b) % p : " , key_ab)

    # since we know p , g , g^a % p , and have been given the g^b & p
    # To find the g^(a*b) % p , we either have to find K1 or K2
    # K1 = (g^a % p) ^ b % p  which in other word do run
    # the mod_exp(with g^a % p as the base)
    # Same with K2 = (g^b % p) ^ a % p
    # since g^(a*b) % p  = K1 = K2

    g = 4386464427469509894907945505819185525461163120059951319316936635307915320367491096421612159620897722212210816421698760084152545104681451115798985756460
    key_b = modular_exponentiation(g, a, p)
    print("secret_key: ", key_b)

diffie_hellman(a, p)